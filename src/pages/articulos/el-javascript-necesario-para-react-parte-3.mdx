---
layout: ../../layouts/article/index.astro
title: "El Javascript necesario para React - Parte 3"
slug: "el-javascript-necesario-para-react-parte-3"
description: "Â¡Domina la asincronÃ­a en JavaScript! Aprende sobre template literals para strings multi-lÃ­nea e interpolaciÃ³n de variables, callbacks, promesas y la elegante sintaxis async/await.  Simplifica tu cÃ³digo y maneja operaciones asincrÃ³nicas con eficiencia. Â¡Mejora tu desarrollo web ahora!"
date: 2024-09-29T01:35:00-03:00
categories: ["web-development", "javascript"]
seo_image: /images/articulos/el-javascript-necesario-para-react/parte-3/el-javascript-necesario-para-react-parte-3.webp
sections:
  [
    { title: "Templates literal", anchor: "templates-literal" },
    { title: "AsincronÃ­a", anchor: "asynchrony" },
    { title: "Callbacks", anchor: "callbacks" },
    { title: "Promesas", anchor: "promises" },
    { title: "Async/Await", anchor: "async-await" },
  ]
---

<h2 id="templates-literal">Templates literal</h2>

Las **templates literals** ğŸ¨ son una caracterÃ­stica dentro de JavaScript que nos permite hacer dos cosas super concretas con una **sintaxis sÃºper simple**, usando **tildes invertidas** **\`** o tambiÃ©n llamados [**grave accent**](https://en.wikipedia.org/wiki/Grave_accent). Primero: Nos permite **dar saltos de lÃ­nea** dentro del string y la segunda: **poder interpolar variables** dentro de una cade de texto o string.

_Lector: No entiendo nada de lo que estÃ¡s diciendo. ğŸ™ƒ_

_Yo: Mmmh... mejor, veamos algunos ejemplos, porque no me estÃ¡ ayudando el explicar usando solo texto. ğŸ«£_

```javascript
const ğŸ¥º = "Soy un texto que no le
permiten dar saltos de linea"
```

Si vemos en este ejemplo, estamos declarando una variable con un texto usando comillas dobles (para efectos de este ejemplo usÃ© comillas dobles, pero el resultado serÃ¡ el mismo si usamos comillas simples).

_ğŸ‘€ Si nos damos cuenta, el mismo ejemplo nos estÃ¡ marcando de distinto color las letras que estÃ¡n en la segunda lÃ­nea._

En el ejemplo que veremos a continuaciÃ³n, al estar usando las tildes invertidas, no nos estÃ¡ generando ningÃºn error, es mÃ¡s, se ve como que el color no cambia (no como en el ejemplo anterior).

```javascript
const ğŸ’ª = `Yo si puedo
muajajajaja ğŸ˜ˆ`;
```

Ojo âš ï¸, que esto no es lo Ãºnico que se puede hacer con las templates literals, ya que tambiÃ©n podemos concatenar variables dentro del mismo string, sin necesidad de hacer cosas extraÃ±as como sumar variables y cosas asÃ­. _**Pero Wait!**_ ğŸ›‘, necesitamos utilizar una nueva forma de decirle al string que lo que va a continuaciÃ³n es una variable.

_Lector: pff otra cosa mÃ¡s por aprender... ğŸ˜“_

_Yo: Tranquilidad, que con los ejemplos que vamos a ver ahora, lo vas a aprender sÃºper rÃ¡pido. ğŸš€_

### Sin templates literal

```javascript
const usuario = {
  nombre: "Arthur",
  edad: 30,
};

console.log("Hola! mi nombre es " + usuario.nombre + " y tengo " + usuario.edad + " aÃ±os.");

// output: Hola! mi nombre es Arthur y tengo 30 aÃ±os
```

### Con templates literal

```javascript
const usuario = {
  nombre: "Arthur",
  edad: 30,
};

console.log(`Hola! mi nombre es ${usuario.nombre} y tengo ${usuario.edad} aÃ±os.`);
// output: Hola! mi nombre es Arthur y tengo 30 aÃ±os
```

En ambos ejemplos tenemos exactamente el mismo resultado. QuerÃ­amos poder **concatenar/unir texto con variables** y esto se pudo lograr **de dos maneras**, lo cual no estÃ¡ tan malo. Ahora, no te pasa que al ver ambos ejemplos, sientes que uno es mÃ¡s... **intuitivo**? o por lo menos, mÃ¡s **sencillo de leer** ğŸ“–, y lo Ãºnico que tuvimos que aprender fue saber cÃ³mo envolver las variables dentro del mismo string.

Ahora, siendo un poco mÃ¡s formal con la explicaciÃ³n, para poder **interpolar variables**, necesitamos _"envolver"_ esta misma entre **llaves**, anteponiendo el sÃ­mbolo dÃ³lar **($)** quedando la siguiente estructura: `${...}`.

<h2 id="asynchrony">AsincronÃ­a</h2>

En **JavaScript**, muchas veces necesitamos ejecutar tareas que no se **completan de inmediato**, como solicitar datos de una **API** ğŸŒ o **leer un archivo** ğŸ“‚. Estas tareas son conocidas como operaciones asincrÃ³nicas â³, y nos permiten continuar ejecutando el resto del cÃ³digo sin esperar a que esas tareas se terminen. A esto se le llama asincronÃ­a.

_Lector: Â¿QuÃ©? Â¡No entiendo nada!_

_Yo: Tranquilo, lo explicarÃ© con un ejemplo simple._

ImagÃ­nate que tienes una funciÃ³n que espera 2 segundos â±ï¸ para darte un resultado. Mientras esperas, Â¿quÃ© haces? Pues, sigues trabajando en otras cosas ğŸ› ï¸, y cuando el resultado llega, lo utilizas. AsÃ­ es como funciona la asincronÃ­a en JavaScript.

```javascript
console.log("Inicio de la tarea");

setTimeout(() => {
  console.log("Esto se ejecuta despuÃ©s de 2 segundos");
}, 2000);

console.log("Fin de la tarea");
```

En este ejemplo, setTimeout es una funciÃ³n asincrÃ³nica que espera 2 segundos antes de ejecutar su cÃ³digo. Mientras tanto, el resto del cÃ³digo sigue ejecutÃ¡ndose sin detenerse. Â¡Eso es la magia de la asincronÃ­a! âœ¨

<h2 id="callbacks">Callbacks</h2>

Antes de que existieran las **promesas** (de las que hablaremos mÃ¡s adelante), las operaciones _asincrÃ³nicas en JavaScript_ usaban _**funciones callback**_ para manejar los resultados. Un **callback** es simplemente una _**funciÃ³n que se pasa como argumento a otra funciÃ³n**_ y se ejecuta cuando la operaciÃ³n asincrÃ³nica ha finalizado.

Veamos un ejemplo clÃ¡sico:

```javascript
function pedirDatos(callback) {
  setTimeout(() => {
    const datos = { nombre: "Bruce Banner", edad: 56 };
    callback(datos);
  }, 3000);
}

pedirDatos((resultado) => {
  console.log("Datos recibidos:", resultado);
});
```

AquÃ­ estamos usando un callback para procesar los datos una vez que han sido obtenidos despuÃ©s de 3 segundos. Esta era una de las primeras maneras de manejar la asincronÃ­a, pero como veremos mÃ¡s adelante, tiene algunos inconvenientes cuando las operaciones se complican, lo que da lugar a algo llamado **Callback Hell ğŸ˜±**.

![Elmo in the hell](https://media.giphy.com/media/11qCjC856PSmnm/giphy.gif)

<h2 id="promises">Promesas</h2>

**Una promesa** ğŸ“œ es un **objeto** que representa el eventual resultado (o fallo) de una _**operaciÃ³n asincrÃ³nica**_. En lugar de pasar un **callback como argumento**, las promesas te permiten trabajar con la asincronÃ­a de una manera mucho **mÃ¡s legible**, utilizando los mÃ©todos _**.then()**_, _**.catch()**_ y _**.finally()**_.

### Veamos cÃ³mo funciona:

```javascript
const promesaDeDatos = new Promise((resolve, reject) => {
  setTimeout(() => {
    const exito = true; // Cambia esto a false para ver el catch

    if (exito) {
      resolve({ nombre: "Bruce Banner", edad: 56 });
    } else {
      reject("Hubo un error al obtener los datos");
    }
  }, 3000);
});

promesaDeDatos
  .then((resultado) => {
    console.log("Datos recibidos:", resultado);
  })
  .catch((error) => {
    console.error("Error:", error);
  })
  .finally(() => {
    console.log("OperaciÃ³n completada");
  });
```

Con las promesas podemos gestionar mÃ¡s fÃ¡cilmente los resultados exitosos o los errores, evitando el **Callback Hell**. En este ejemplo, si todo va bien, **resolve** se ejecuta, y si hay un error, se ejecuta **reject**. Â¡SÃºper Ãºtil! ğŸš€

<h2 id="async-await">Async/Await</h2>

Si pensabas que las promesas ya hacÃ­an la asincronÃ­a mÃ¡s sencilla Â¡espera a conocer **async/await!** ğŸš€ Esta caracterÃ­stica permite que escribamos cÃ³digo asÃ­ncrono de una manera aÃºn mÃ¡s limpia y directa. Parece que todo sucede de manera sÃ­ncrona, pero en realidad estÃ¡ manejando promesas en el fondo.

Para usar _**async/await**_, solo necesitas declarar una funciÃ³n como async y usar await para esperar los resultados de las promesas.

Veamos un ejemplo:

```javascript
async function obtenerDatos() {
  try {
    const resultado = await promesaDeDatos;
    console.log("Datos recibidos:", resultado);
  } catch (error) {
    console.error("Error:", error);
  } finally {
    console.log("OperaciÃ³n completada");
  }
}

obtenerDatos();
```

Con **async/await**, el cÃ³digo parece mÃ¡s _**lineal y fÃ¡cil de seguir**_ ğŸ‘£. En lugar de usar **.then()** y **.catch()**, simplemente usamos **await** para _"esperar"_ el resultado de la promesa. Si algo sale mal, lo manejamos con _**try/catch**_, como lo harÃ­amos con cÃ³digo sÃ­ncrono.

![Confused Cat](https://media.giphy.com/media/l2RsBhyCSu5Y5XU3Zf/giphy.gif)
